import { NextRequest, NextResponse } from 'next/server';\nimport { stripe } from '@/lib/stripe';\nimport { supabase } from '@/lib/supabase';\nimport { randomUUID } from 'crypto';\nimport Stripe from 'stripe';\n\nconst webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n\nif (!webhookSecret) {\n  console.warn('Missing STRIPE_WEBHOOK_SECRET environment variable');\n}\n\nexport async function POST(req: NextRequest) {\n  try {\n    const body = await req.text();\n    const signature = req.headers.get('stripe-signature');\n\n    if (!signature || !webhookSecret) {\n      return NextResponse.json(\n        { error: 'Missing signature or webhook secret' },\n        { status: 400 }\n      );\n    }\n\n    let event: Stripe.Event;\n\n    try {\n      event = stripe.webhooks.constructEvent(body, signature, webhookSecret);\n    } catch (err) {\n      console.error('Webhook signature verification failed:', err);\n      return NextResponse.json(\n        { error: 'Invalid signature' },\n        { status: 400 }\n      );\n    }\n\n    // Handle the event\n    switch (event.type) {\n      case 'payment_intent.succeeded': {\n        const paymentIntent = event.data.object as Stripe.PaymentIntent;\n        await handlePaymentSuccess(paymentIntent);\n        break;\n      }\n      case 'payment_intent.payment_failed': {\n        const paymentIntent = event.data.object as Stripe.PaymentIntent;\n        await handlePaymentFailure(paymentIntent);\n        break;\n      }\n      case 'payment_intent.canceled': {\n        const paymentIntent = event.data.object as Stripe.PaymentIntent;\n        await handlePaymentCancellation(paymentIntent);\n        break;\n      }\n      default:\n        console.log(`Unhandled event type: ${event.type}`);\n    }\n\n    return NextResponse.json({ received: true });\n  } catch (error) {\n    console.error('Webhook error:', error);\n    return NextResponse.json(\n      { error: 'Webhook processing failed' },\n      { status: 500 }\n    );\n  }\n}\n\nasync function handlePaymentSuccess(paymentIntent: Stripe.PaymentIntent) {\n  try {\n    // Get payment record\n    const { data: payment, error: paymentError } = await supabase\n      .from('Payment')\n      .select('*')\n      .eq('stripePaymentIntentId', paymentIntent.id)\n      .single();\n\n    if (paymentError || !payment) {\n      console.error('Payment record not found for webhook:', paymentIntent.id);\n      return;\n    }\n\n    if (payment.status === 'COMPLETED') {\n      console.log('Payment already processed:', paymentIntent.id);\n      return;\n    }\n\n    // Update payment status\n    const { error: updateError } = await supabase\n      .from('Payment')\n      .update({\n        status: 'COMPLETED',\n        paidAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n      })\n      .eq('id', payment.id);\n\n    if (updateError) {\n      console.error('Error updating payment status in webhook:', updateError);\n      return;\n    }\n\n    // Create vote record\n    const currentRound = Math.ceil(\n      (Date.now() - new Date('2025-01-01').getTime()) / (7 * 24 * 60 * 60 * 1000)\n    );\n\n    const { error: voteError } = await supabase\n      .from('Vote')\n      .insert({\n        id: randomUUID(),\n        userId: payment.userId,\n        contestantId: payment.contestantId,\n        voteCount: payment.voteCount,\n        isPaid: true,\n        amount: payment.amount,\n        transactionId: paymentIntent.id,\n        status: 'ACTIVE',\n        votingRound: currentRound,\n        createdAt: new Date().toISOString(),\n      });\n\n    if (voteError) {\n      console.error('Error creating vote record in webhook:', voteError);\n      return;\n    }\n\n    console.log('Payment processed successfully via webhook:', paymentIntent.id);\n  } catch (error) {\n    console.error('Error handling payment success:', error);\n  }\n}\n\nasync function handlePaymentFailure(paymentIntent: Stripe.PaymentIntent) {\n  try {\n    const { error } = await supabase\n      .from('Payment')\n      .update({\n        status: 'FAILED',\n        failureReason: paymentIntent.last_payment_error?.message || 'Payment failed',\n        updatedAt: new Date().toISOString(),\n      })\n      .eq('stripePaymentIntentId', paymentIntent.id);\n\n    if (error) {\n      console.error('Error updating failed payment:', error);\n    }\n  } catch (error) {\n    console.error('Error handling payment failure:', error);\n  }\n}\n\nasync function handlePaymentCancellation(paymentIntent: Stripe.PaymentIntent) {\n  try {\n    const { error } = await supabase\n      .from('Payment')\n      .update({\n        status: 'FAILED',\n        failureReason: 'Payment canceled by user',\n        updatedAt: new Date().toISOString(),\n      })\n      .eq('stripePaymentIntentId', paymentIntent.id);\n\n    if (error) {\n      console.error('Error updating canceled payment:', error);\n    }\n  } catch (error) {\n    console.error('Error handling payment cancellation:', error);\n  }\n}"